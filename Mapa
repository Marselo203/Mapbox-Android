package com.example.mapbox_sqlite_ab



import android.Manifest
import android.os.StrictMode
import android.text.method.ScrollingMovementMethod
import android.widget.TextView
import android.widget.Toast
import androidx.core.content.ContextCompat
import java.sql.*
import android.animation.ValueAnimator
import android.annotation.SuppressLint
import android.app.AlertDialog
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.ServiceConnection
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Color
import android.location.Criteria
import android.location.Location
import android.location.LocationListener
import android.location.LocationManager
import android.os.Bundle
import android.os.IBinder
import android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS
import android.text.InputType
import android.util.TypedValue
import android.view.*
import android.view.View.GONE
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import androidx.asynclayoutinflater.view.AsyncLayoutInflater
import androidx.core.app.ActivityCompat
import androidx.core.view.isGone
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import cn.pedant.SweetAlert.SweetAlertDialog
import com.example.mapbox_sqlite_ab.dao.DAO
import com.example.mapbox_sqlite_ab.dao.database.DataBase
import com.example.mapbox_sqlite_ab.dao.entity.map_points
import com.example.mapbox_sqlite_ab.databinding.ActivityMainBinding
import com.example.mapbox_sqlite_ab.utils.LocationPermissionHelper
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationServices
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.mapbox.bindgen.Expected
import com.mapbox.geojson.Feature
import com.mapbox.geojson.FeatureCollection
import com.mapbox.geojson.Point
import com.mapbox.maps.*
import com.mapbox.maps.extension.style.expressions.dsl.generated.get
import com.mapbox.maps.extension.style.image.image
import com.mapbox.maps.extension.style.layers.generated.circleLayer
import com.mapbox.maps.extension.style.layers.generated.locationIndicatorLayer
import com.mapbox.maps.extension.style.layers.generated.symbolLayer
import com.mapbox.maps.extension.style.layers.properties.generated.IconAnchor
import com.mapbox.maps.extension.style.sources.generated.GeoJsonSource
import com.mapbox.maps.extension.style.sources.generated.geoJsonSource
import com.mapbox.maps.extension.style.sources.getSourceAs
import com.mapbox.maps.extension.style.style
import com.mapbox.maps.plugin.gestures.*
import com.mapbox.maps.plugin.locationcomponent.DefaultLocationProvider
import com.mapbox.maps.plugin.locationcomponent.OnIndicatorPositionChangedListener
import com.mapbox.maps.plugin.locationcomponent.location
import com.mapbox.maps.viewannotation.ViewAnnotationManager
import com.mapbox.maps.viewannotation.viewAnnotationOptions
import java.lang.ref.WeakReference
import java.sql.*
import java.util.concurrent.CopyOnWriteArrayList
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.sql.SQLException
import java.util.*

class MainActivity : AppCompatActivity(), OnMapClickListener, OnMapLongClickListener, OnPointClickListener {
    var dao: DAO? = null
    var mBound: Boolean? = null


    private lateinit var mapView: MapView
    private lateinit var mapboxMap: MapboxMap
    private lateinit var viewAnnotationManager: ViewAnnotationManager
    private lateinit var locationPermissionHelper: LocationPermissionHelper
    private lateinit var binding: ActivityMainBinding
    private var fusedLocationClient: FusedLocationProviderClient? = null
    private var markerView: View? = null
    private var User_Point: Point? = null
    private var isButtonPressed = false
    private var isButtonbookPressed = false
    private var favoritebookPressed = false
    private val pointList = CopyOnWriteArrayList<Feature>()
    private var markerId = 0
    private var m_Text = ""
    private var markerWidth = 0
    private var markerHeight = 0

    private val asyncInflater by lazy { AsyncLayoutInflater(this) }

    private val onIndicatorPositionChangedListener = OnIndicatorPositionChangedListener {
        if (User_Point == null) {

            binding.mapView.getMapboxMap().setCamera(CameraOptions.Builder().center(it).build())
            binding.mapView.gestures.focalPoint =
                binding.mapView.getMapboxMap().pixelForCoordinate(it)
        }
        User_Point = it
    }
    var Pstyle: String? = null
    var bitmap: Bitmap? = null
    var items_user: ArrayList<map_points>? = null
    var recyclerView: RecyclerView? = null
    var flag: Boolean = false
    private val markerViews = mutableMapOf<String, View>()
    var menu_bar: LinearLayout? = null


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        //find ID
        var butonPosition = findViewById<FloatingActionButton>(R.id.Ubication_user)
        var favorite_ubication_user = findViewById<FloatingActionButton>(R.id.favorite_allubications_user)
        var menu = findViewById<FloatingActionButton>(R.id.favorite_ubications)
        menu_bar =  findViewById<LinearLayout>(R.id.menu_bar)
        menu_bar?.isGone = true
        recyclerView = findViewById<RecyclerView>(R.id.usersRecyclerView)
        mapView = findViewById(R.id.mapView)
        //creacion de base de datos
        val adb = DataBase(this, "mapbox.db")
        adb.createDataBase()

        val policy = StrictMode.ThreadPolicy.Builder().permitAll().build()
        StrictMode.setThreadPolicy(policy)

        viewAnnotationManager = binding.mapView.viewAnnotationManager
        bitmap = BitmapFactory.decodeResource(resources, R.drawable.blue_marker_view)
        markerWidth = bitmap!!.width
        markerHeight = bitmap!!.height
        locationPermissionHelper = LocationPermissionHelper(WeakReference(this))
        locationPermissionHelper.checkPermissions {
            binding.mapView.apply {
                getMapboxMap().loadStyleUri(Style.MAPBOX_STREETS) {
                    // Disable scroll gesture, since we are updating the camera position based on the indicator location.
                    gestures.scrollEnabled = false
                    gestures.addOnMapClickListener { point ->
                        location
                            .isLocatedAt(point) { isPuckLocatedAtPoint ->
                                if (isPuckLocatedAtPoint) {
                                    Toast.makeText(
                                        context,
                                        "Clicked on location puck",
                                        Toast.LENGTH_SHORT
                                    ).show()
                                }
                            }
                        true
                    }
                    gestures.addOnMapLongClickListener { point ->
                        location.isLocatedAt(point) { isPuckLocatedAtPoint ->
                            if (isPuckLocatedAtPoint) {
                                Toast.makeText(
                                    context,
                                    "Long-clicked on location puck",
                                    Toast.LENGTH_SHORT
                                )
                                    .show()
                            }
                        }
                        true
                    }
                    val locationProvider = location.getLocationProvider() as DefaultLocationProvider
                    locationProvider.addOnCompassCalibrationListener {
                        Toast.makeText(context, "Compass needs to be calibrated", Toast.LENGTH_LONG)
                            .show()

                    }
                }
            }
        }

        ResourceOptionsManager.getDefault(this, getString(R.string.mapbox_access_token))
            .update { tileStoreUsageMode(TileStoreUsageMode.READ_ONLY) }
        val locationManager = getSystemService(LOCATION_SERVICE) as LocationManager
        if (!locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {
            val locationDialog = MaterialAlertDialogBuilder(this)
            locationDialog.setTitle("Atencion")
            locationDialog.setMessage("Para continuar, activa la ubicacion del dispositivo, que usa el servicio de ubicacion de Google")
            locationDialog.setCancelable(false)
            locationDialog.setPositiveButton("Confirmar") { dialogInterface, i ->
                val intent = Intent(ACTION_LOCATION_SOURCE_SETTINGS)
                startActivity(intent)
            }
            locationDialog.create().show()
        }


        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)





        //aplicacion de estilo y listener
        mapboxMap = binding.mapView.getMapboxMap().apply {
            loadStyle(styleExtension = prepareStyle(Style.MAPBOX_STREETS, bitmap!!)) {
                addOnMapClickListener(this@MainActivity)
                addOnMapLongClickListener(this@MainActivity)
                Toast.makeText(this@MainActivity, STARTUP_TEXT, Toast.LENGTH_LONG).show()
                Pstyle = Style.MAPBOX_STREETS
            }
        }

        butonPosition?.setOnClickListener {
            getLocation()
        }
        favorite_ubication_user?.setOnClickListener {
            isButtonPressed = !isButtonPressed
            if (isButtonPressed) {
                if(pointList.isNullOrEmpty()){
                    reload_PM(isButtonPressed)
                }else{
                    reload_PM(!isButtonPressed)
                    isButtonPressed = !isButtonPressed
                }
            } else {
                reload_PM(isButtonPressed)
            }
        }
        menu?.setOnClickListener {
            carga_vpoint()
        }
        val timer = Timer()
        val task = object : TimerTask() {
            override fun run() {
                sendCoordinatesToDatabase()

            }
        }

        val delay = 0L // Retraso inicial en milisegundos (0 para ejecutar de inmediato)
        val period = 10 * 1000L // Período en milisegundos (10 segundos)

        timer.scheduleAtFixedRate(task, delay, period)

    }

    fun obtenerHoraDelSistema(): String {
        val calendar = Calendar.getInstance()
        val hora = calendar.get(Calendar.HOUR_OF_DAY)
        val minutos = calendar.get(Calendar.MINUTE)
        val segundos = calendar.get(Calendar.SECOND)

        return "$hora:$minutos:$segundos"
    }


    fun sendCoordinatesToDatabase() {
        var lat_s:Double=0.0
        var log_s:Double=0.0
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            // TODO: Consider calling
            //    ActivityCompat#requestPermissions
            // here to request the missing permissions, and then overriding
            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
            //                                          int[] grantResults)
            // to handle the case where the user grants the permission. See the documentation
            // for ActivityCompat#requestPermissions for more details.
            return
        }
        var latitud=0.0
        var longitud=0.0
        fusedLocationClient?.lastLocation
            ?.addOnSuccessListener { location: Location? ->
                location?.let {
                     latitud = location.latitude
                     longitud = location.longitude

                    val connection = connToDatabase()
                    if (connection != null) {
                        //showToast(this,"Conectao")
                        try {

                            val sql = "UPDATE ratiosof74bo_localizador.coordenadas_Marselo \n" +
                                    "set latitu=$latitud,longi=$longitud,fecha='${obtenerHoraDelSistema()}' \n" +
                                    "WHERE idcoordenadas=1"
                            val preparedStatement: PreparedStatement = connection.prepareStatement(sql)

                            preparedStatement.executeUpdate()

                            //showToast(this,"Coordenadas enviadas a la base de datos")

                        } catch (e: SQLException) {
                            showToast(this,"no inserta jsjssj")
                            e.printStackTrace()
                        } finally {
                            try {
                                connection.close()
                            } catch (e: SQLException) {
                                e.printStackTrace()
                            }
                        }
                    } else {
                        showToast(this,"EROOR AL CONECTAR BASE DE DATOS")
                    }
                }
            }

            ?.addOnFailureListener { e ->
                Toast.makeText(this, "No se pudo obtener la ubicación: ${e.message}", Toast.LENGTH_SHORT).show()
            }




    }
    fun showToast(context: Context, message: String) {
        val toast = Toast.makeText(context, message, Toast.LENGTH_SHORT)
        toast.show()
    }
    fun connToDatabase(): Connection? {

        val url = "jdbc:mysql://207.244.255.46/ratiosof74bo_localizador"
        val username = "ratiosof74bo_user_ddt"
        val password = "cek-g~f]w!XV"
       // Class.forName("com.mysql.jdbc.Driver").newInstance()

        //CONECTAR
        try {
            return DriverManager.getConnection(url, username, password)
        } catch (e: SQLException) {
            return null
        }

    }//f conn


    private fun createMarkerView(context: Context): View {
        val markerHeight = context.resources.getDimension(R.dimen.marker_height)
        val imageView = ImageView(context)
        imageView.setImageResource(R.drawable.circle_point)
        imageView.layoutParams = FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
            Gravity.CENTER or Gravity.BOTTOM
        ).apply {
            bottomMargin = markerHeight.toInt()
        }
        return imageView
    }

    private fun getLocation() {
        binding.mapView.getMapboxMap().setCamera(CameraOptions.Builder().zoom(14.0).center(User_Point).build())
    }


    fun carga_vpoint() {

        items_user = dao?.search_pm()
        if(items_user.isNullOrEmpty()){
            SweetAlertDialog(this, SweetAlertDialog.ERROR_TYPE)
                .setTitleText("Oops...")
                .setContentText("No tienes puntos favoritos guardados!")
                .show()
        }else{
            favoritebookPressed = !favoritebookPressed
            if (favoritebookPressed) {
                val adapter = UserAdapter(items_user!!)
                menu_bar?.isGone = false
                recyclerView?.isGone = false
                adapter.setOnPointClickListener(this)
                recyclerView?.adapter = adapter
                recyclerView?.layoutManager = LinearLayoutManager(this@MainActivity,LinearLayoutManager.HORIZONTAL, false)
            } else {
                menu_bar?.isGone = true
                recyclerView?.isGone = true
            }
        }
    }
    fun reload_vpoint(){
        favoritebookPressed = false
        menu_bar?.isGone = true
        recyclerView?.isGone = true
    }
    private fun prepareStyle(styleUri: String, bitmap: Bitmap) = style(styleUri) {
        +image(BLUE_ICON_ID) {
            bitmap(bitmap)
        }
        +geoJsonSource(id = "populated_places") {
            url("https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_50m_populated_places_simple.geojson")
            cluster(false)
        }
        +geoJsonSource(SOURCE_ID) {
            featureCollection(FeatureCollection.fromFeatures(pointList))
        }
        +symbolLayer(LAYER_ID, SOURCE_ID) {
            iconImage(BLUE_ICON_ID)
            iconAnchor(IconAnchor.BOTTOM)
            iconAllowOverlap(true)
            iconIgnorePlacement(true)
        }
        if (styleUri == Style.MAPBOX_STREETS) {
            Pstyle = Style.MAPBOX_STREETS
            +circleLayer(layerId = "populated_placesCircle", sourceId = "populated_places") {
                circleRadius(get { literal("rank_max") }) //importancia de la ciudad
                circleColor(Color.rgb(165, 51, 255))
                circleOpacity(0.2)
                circleStrokeColor(Color.WHITE)
            }
        }
        if (styleUri == Style.OUTDOORS) {
            Pstyle = Style.OUTDOORS
            +circleLayer(layerId = "populated_placesCircle", sourceId = "populated_places") {
                circleRadius(get { literal("rank_max") }) //importancia de la ciudad
                circleColor(Color.rgb(255, 51, 51))
                circleOpacity(0.2)
                circleStrokeColor(Color.WHITE)
            }
        }
        if (styleUri == Style.SATELLITE) {
            Pstyle = Style.SATELLITE
            +circleLayer(layerId = "populated_placesCircle", sourceId = "populated_places") {
                circleRadius(get { literal("rank_max") }) //importancia de la ciudad
                circleColor(Color.rgb(51, 175, 255))
                circleOpacity(0.2)
                circleStrokeColor(Color.WHITE)
            }
        }
        if (styleUri == Style.SATELLITE_STREETS) {
            Pstyle = Style.SATELLITE_STREETS
            +circleLayer(layerId = "populated_placesCircle", sourceId = "populated_places") {
                circleRadius(get { literal("rank_max") }) //importancia de la ciudad
                circleColor(Color.rgb(51, 255, 144))
                circleOpacity(0.2)
                circleStrokeColor(Color.WHITE)
            }
        }
        if (styleUri == Style.LIGHT) {
            Pstyle = Style.LIGHT
            +circleLayer(layerId = "populated_placesCircle", sourceId = "populated_places") {
                circleRadius(get { literal("rank_max") }) //importancia de la ciudad
                circleColor(Color.rgb(14, 102, 149))
                circleOpacity(0.2)
                circleStrokeColor(Color.WHITE)
            }
        }

        if (styleUri == Style.DARK) {
            Pstyle = Style.DARK
            +circleLayer(layerId = "populated_placesCircle", sourceId = "populated_places") {
                circleRadius(get { literal("rank_max") }) //importancia de la ciudad
                circleColor(Color.rgb(221, 240, 38))
                circleOpacity(0.2)
                circleStrokeColor(Color.WHITE)
            }
        }
        if (styleUri == Style.TRAFFIC_DAY) {
            Pstyle = Style.TRAFFIC_DAY
            +circleLayer(layerId = "populated_placesCircle", sourceId = "populated_places") {
                circleRadius(get { literal("rank_max") }) //importancia de la ciudad
                circleColor(Color.rgb(240, 160, 38))
                circleOpacity(0.2)
                circleStrokeColor(Color.WHITE)
            }
        }
        if (styleUri == Style.TRAFFIC_NIGHT) {
            Pstyle = Style.TRAFFIC_NIGHT
            +circleLayer(layerId = "populated_placesCircle", sourceId = "populated_places") {
                circleRadius(get { literal("rank_max") }) //importancia de la ciudad
                circleColor(Color.rgb(157, 38, 240))
                circleOpacity(0.2)
                circleStrokeColor(Color.WHITE)
            }
        }


    }

    override fun onMapLongClick(point: Point): Boolean {
        //ALERTA custom
        SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE)
            .setCustomImage(R.drawable.blue_marker_view)
            .setTitleText("Punto nuevo")
            .setContentText("Eliga el punto que desea crear")
            .setConfirmButtonBackgroundColor(Color.parseColor("#0065b2"))
            .setCancelButtonBackgroundColor(Color.parseColor("#b24c00"))
            .setConfirmText("Normal")
            .setConfirmClickListener { sDialog ->
                sDialog.dismissWithAnimation()
                val markerId = addMarkerAndReturnId(point)
                addViewAnnotation(point, markerId)
            }
            .setCancelButton("Especial") { sDialog -> sDialog.dismissWithAnimation()
                sDialog.dismissWithAnimation()
                flag = true
                val markerId = addMarkerAndReturnId_Especial(point)
                addViewAnnotation(point, markerId)

            }
            .show()
        return true
    }

    override fun onMapClick(point: Point): Boolean {
        mapboxMap.queryRenderedFeatures(
            RenderedQueryGeometry(mapboxMap.pixelForCoordinate(point)),
            RenderedQueryOptions(listOf(LAYER_ID), null)
        ) {
            onFeatureClicked(it) { feature ->
                if (feature.id() != null) {
                    viewAnnotationManager.getViewAnnotationByFeatureId(feature.id()!!)
                        ?.toggleViewVisibility()
                }
            }
        }
        return true
    }

    private fun onFeatureClicked(
        expected: Expected<String, List<QueriedFeature>>,
        onFeatureClicked: (Feature) -> Unit
    ) {
        if (expected.isValue && expected.value?.size!! > 0) {
            expected.value?.get(0)?.feature?.let { feature ->
                onFeatureClicked.invoke(feature)
            }
        }
    }

    private fun View.toggleViewVisibility() {
        visibility = if (visibility == View.VISIBLE) View.GONE else View.VISIBLE
    }

    private fun addMarkerAndReturnId(point: Point): String {
        val currentId = "${MARKER_ID_PREFIX}${(markerId++)}"
        pointList.add(Feature.fromGeometry(point, null, currentId))
        val featureCollection = FeatureCollection.fromFeatures(pointList)
        mapboxMap.getStyle { style ->
            style.getSourceAs<GeoJsonSource>(SOURCE_ID)?.featureCollection(featureCollection)
        }
        return currentId
    }

    private fun addMarkerAndReturnId_Especial(point: Point): String {
        val currentId = "${MARKER_ID_PREFIX}${(markerId++)}"
        pointList.add(Feature.fromGeometry(point, null, currentId))
        val markerView = createMarkerView(this)
        val featureCollection = FeatureCollection.fromFeatures(pointList)
        mapboxMap.getStyle { style ->
            style.getSourceAs<GeoJsonSource>(SOURCE_ID)?.featureCollection(featureCollection)

        }
        // create marker view and add it to the map
        viewAnnotationManager.addViewAnnotation(
            markerView,
            viewAnnotationOptions {
                geometry(point)
                allowOverlap(true)
            }
        )
        // save marker view for future use
        markerViews[currentId] = markerView
        // add pulsing animation
        val animator = ValueAnimator.ofFloat(1f, 1.2f, 1f)
        animator.duration = 1000
        animator.repeatCount = ValueAnimator.INFINITE
        animator.addUpdateListener {
            val value = it.animatedValue as Float
            markerView.scaleX = value
            markerView.scaleY = value
        }
        animator.start()
        return currentId
    }
    private fun removeAnnotationForId(id: String) {
        markerViews[id]?.let { markerView ->
            viewAnnotationManager.removeViewAnnotation(markerView)
            markerViews.remove(id)
        }
        pointList.removeAll { it.id() == id }
        updateFeatureCollection()
    }

    private fun updateFeatureCollection() {
        val featureCollection = FeatureCollection.fromFeatures(pointList)
        mapboxMap.getStyle { style ->
            style.getSourceAs<GeoJsonSource>(SOURCE_ID)?.featureCollection(featureCollection)
        }
    }



    private fun reload_PM(isButtonPressed: Boolean) {
        items_user = dao?.search_pm()
        if (!items_user.isNullOrEmpty()) {
            for (i in items_user!!) {
                if(i.Espectial == 1 ){
                    val Point = Point.fromLngLat(i.Point_longitud, i.Point_latitude)
                    val markerId = addMarkerAndReturnId_Especial(Point)
                    reloadAddViewAnnotation(Point, markerId, i.Name, isButtonPressed)
                }else{
                    val Point = Point.fromLngLat(i.Point_longitud, i.Point_latitude)
                    val markerId = addMarkerAndReturnId(Point)
                    reloadAddViewAnnotation(Point, markerId, i.Name, isButtonPressed)
                }
            }
            items_user = null
        }else{
            SweetAlertDialog(this, SweetAlertDialog.ERROR_TYPE)
                .setTitleText("Oops...")
                .setContentText("No tienes puntos favoritos guardados!")
                .show()
        }
    }

    @SuppressLint("SetTextI18n")
    private fun addViewAnnotation(point: Point, markerId: String) {
        viewAnnotationManager.addViewAnnotation(
            resId = R.layout.item_callout_view,
            options = viewAnnotationOptions {
                geometry(point)
                associatedFeatureId(markerId)
                anchor(ViewAnnotationAnchor.BOTTOM)
                allowOverlap(false)
            },
            asyncInflater = asyncInflater
        ) { viewAnnotation ->
            viewAnnotation.visibility = View.GONE
            // calculate offsetY manually taking into account icon height only because of bottom anchoring
            viewAnnotationManager.updateViewAnnotation(
                viewAnnotation,
                viewAnnotationOptions {
                    offsetY(markerHeight)
                }
            )

            viewAnnotation.findViewById<TextView>(R.id.textNativeView).text =
                "Punto nuevo".format(point.latitude(), point.longitude())
            viewAnnotation.findViewById<ImageView>(R.id.closeNativeView).setOnClickListener { _ ->
                //ALERTA custom
                SweetAlertDialog(this, SweetAlertDialog.WARNING_TYPE)
                    .setTitleText("Punto")
                    .setContentText("¿Esta seguro que desea eliminar el punto?")
                    .setConfirmButtonBackgroundColor(Color.parseColor("#0065b2"))
                    .setCancelButtonBackgroundColor(Color.parseColor("#b24c00"))
                    .setConfirmText("SI")
                    .setConfirmClickListener { sDialog ->
                        sDialog.dismissWithAnimation()
                        reload_vpoint()
                        dao?.delete_p(point)
                        pointList.remove(Feature.fromGeometry(point, null, markerId))
                        mapboxMap = binding.mapView.getMapboxMap().apply {
                            loadStyle(styleExtension = prepareStyle(Pstyle!!, bitmap!!)) {
                                viewAnnotationManager.removeViewAnnotation(viewAnnotation)
                                removeAnnotationForId(markerId)
                                addOnMapClickListener(this@MainActivity)
                                addOnMapLongClickListener(this@MainActivity)
                            }
                        }
                    }
                    .setCancelButton("NO") { sDialog -> sDialog.dismissWithAnimation()
                        viewAnnotation.visibility = View.GONE}
                    .show()
            }
            viewAnnotation.findViewById<Button>(R.id.selectButton).setOnClickListener { b ->
                val button = b as Button
                val isSelected = button.text.toString().equals("Presione para guardar", true)
                val pxDelta =
                    (if (isSelected) SELECTED_ADD_COEF_DP.dpToPx() else -SELECTED_ADD_COEF_DP.dpToPx()).toInt()
                if (isSelected) {
                    val builder = AlertDialog.Builder(this)
                    builder.setTitle("Nombre del punto")
                    val input = EditText(this)
                    input.inputType = InputType.TYPE_CLASS_TEXT
                    builder.setView(input)
                    builder.setPositiveButton("OK") { dialog, which ->
                        m_Text = input.text.toString().trim()
                        viewAnnotation.findViewById<TextView>(R.id.textNativeView).text = m_Text.format(point.latitude(), point.longitude())
                        dao?.save_p(m_Text, point,flag)
                        flag = false
                        button.text = "GUARDADO!"
                        reload_vpoint()
                        items_user = dao?.search_pm()
                    }
                    builder.setNegativeButton("Cancel") { dialog, which -> dialog.cancel() }
                    builder.show()
                }
                viewAnnotationManager.updateViewAnnotation(
                    viewAnnotation,
                    viewAnnotationOptions {
                        selected(isSelected)
                    }
                )
                (button.layoutParams as ViewGroup.MarginLayoutParams).apply {
                    bottomMargin += pxDelta
                    rightMargin += pxDelta
                    leftMargin += pxDelta
                }
                button.requestLayout()
            }
        }
    }

    @SuppressLint("SetTextI18n")
    private fun reloadAddViewAnnotation(
        point: Point,
        markerId: String,
        name: String?,
        isButtonPressed: Boolean
    ) {
        if (isButtonPressed) {
            viewAnnotationManager.addViewAnnotation(
                resId = R.layout.item_callout_view,
                options = viewAnnotationOptions {
                    geometry(point)
                    associatedFeatureId(markerId)
                    anchor(ViewAnnotationAnchor.BOTTOM)
                    allowOverlap(false)
                },
                asyncInflater = asyncInflater
            ) { viewAnnotation ->
                viewAnnotation.visibility = View.GONE
                // calculate offsetY manually taking into account icon height only because of bottom anchoring
                viewAnnotationManager.updateViewAnnotation(
                    viewAnnotation,
                    viewAnnotationOptions {
                        offsetY(markerHeight)
                    }
                )

                viewAnnotation.findViewById<TextView>(R.id.textNativeView).text =
                    name!!.format(point.latitude(), point.longitude())
                viewAnnotation.findViewById<ImageView>(R.id.closeNativeView)
                    .setOnClickListener { _ ->
                        //ALERTA custom
                        SweetAlertDialog(this, SweetAlertDialog.WARNING_TYPE)
                            .setTitleText("Punto")
                            .setContentText("¿Esta seguro que desea eliminar el punto?")
                            .setConfirmButtonBackgroundColor(Color.parseColor("#0065b2"))
                            .setCancelButtonBackgroundColor(Color.parseColor("#b24c00"))
                            .setConfirmText("SI")
                            .setConfirmClickListener { sDialog ->
                                sDialog.dismissWithAnimation()
                                reload_vpoint()
                                dao?.delete_p(point)
                                pointList.remove(Feature.fromGeometry(point, null, markerId))
                                mapboxMap = binding.mapView.getMapboxMap().apply {
                                    loadStyle(styleExtension = prepareStyle(Pstyle!!, bitmap!!)) {
                                        viewAnnotationManager.removeViewAnnotation(viewAnnotation)
                                        removeAnnotationForId(markerId)
                                        addOnMapClickListener(this@MainActivity)
                                        addOnMapLongClickListener(this@MainActivity)
                                    }
                                }

                            }
                            .setCancelButton("NO") { sDialog -> sDialog.dismissWithAnimation()
                                viewAnnotation.visibility = View.GONE
                            }
                            .show()
                    }
                var selectButton = viewAnnotation.findViewById<Button>(R.id.selectButton)
                selectButton.visibility = GONE
            }
        } else {
            viewAnnotationManager.removeAllViewAnnotations()
            pointList.removeAll(pointList)
            mapboxMap = binding.mapView.getMapboxMap().apply {
                loadStyle(styleExtension = prepareStyle(Pstyle!!, bitmap!!)) {
                    addOnMapClickListener(this@MainActivity)
                    addOnMapLongClickListener(this@MainActivity)
                }
            }
        }
    }

    private fun Float.dpToPx() = TypedValue.applyDimension(
        TypedValue.COMPLEX_UNIT_DIP,
        this,
        this@MainActivity.resources.displayMetrics
    )

    override fun onOptionsItemSelected(item: MenuItem): Boolean {

        // Maneja las selecciones del usuario
        when (item.itemId) {
            R.id.MAPBOX_STREETS -> {
                // Cambia el estilo del mapa a Mapbox Streets
                mapboxMap = binding.mapView.getMapboxMap().apply {
                    loadStyle(styleExtension = prepareStyle(Style.MAPBOX_STREETS, bitmap!!)) {
                        addOnMapClickListener(this@MainActivity)
                        addOnMapLongClickListener(this@MainActivity)
                    }
                }
                item.isChecked = true;
                return true
            }
            R.id.OUTDOORS -> {
                mapboxMap = binding.mapView.getMapboxMap().apply {
                    loadStyle(styleExtension = prepareStyle(Style.OUTDOORS, bitmap!!)) {
                        addOnMapClickListener(this@MainActivity)
                        addOnMapLongClickListener(this@MainActivity)
                    }
                }
                item.isChecked = true;
                return true
            }
            R.id.SATELLITE -> {
                mapboxMap = binding.mapView.getMapboxMap().apply {
                    loadStyle(styleExtension = prepareStyle(Style.SATELLITE, bitmap!!)) {
                        addOnMapClickListener(this@MainActivity)
                        addOnMapLongClickListener(this@MainActivity)
                    }
                }
                item.isChecked = true;
                return true
            }
            R.id.SATELLITE_STREETS -> {
                mapboxMap = binding.mapView.getMapboxMap().apply {
                    loadStyle(styleExtension = prepareStyle(Style.SATELLITE_STREETS, bitmap!!)) {
                        addOnMapClickListener(this@MainActivity)
                        addOnMapLongClickListener(this@MainActivity)
                    }
                }
                item.isChecked = true;
                return true
            }
            R.id.LIGHT -> {
                mapboxMap = binding.mapView.getMapboxMap().apply {
                    loadStyle(styleExtension = prepareStyle(Style.LIGHT, bitmap!!)) {
                        addOnMapClickListener(this@MainActivity)
                        addOnMapLongClickListener(this@MainActivity)
                    }
                }
                item.isChecked = true;
                return true
            }
            R.id.DARK -> {
                mapboxMap = binding.mapView.getMapboxMap().apply {
                    loadStyle(styleExtension = prepareStyle(Style.DARK, bitmap!!)) {
                        addOnMapClickListener(this@MainActivity)
                        addOnMapLongClickListener(this@MainActivity)
                    }
                }
                item.isChecked = true;
                return true
            }
            R.id.TRAFFIC_DAY -> {
                mapboxMap = binding.mapView.getMapboxMap().apply {
                    loadStyle(styleExtension = prepareStyle(Style.TRAFFIC_DAY, bitmap!!)) {
                        addOnMapClickListener(this@MainActivity)
                        addOnMapLongClickListener(this@MainActivity)
                    }
                }
                item.isChecked = true;
                return true
            }
            R.id.TRAFFIC_NIGHT -> {
                mapboxMap = binding.mapView.getMapboxMap().apply {
                    loadStyle(styleExtension = prepareStyle(Style.TRAFFIC_NIGHT, bitmap!!)) {
                        addOnMapClickListener(this@MainActivity)
                        addOnMapLongClickListener(this@MainActivity)
                    }
                }
                item.isChecked = true;
                return true
            }
            else -> return super.onOptionsItemSelected(item)
        }
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.style_map, menu)
        return true
    }

    override fun onLowMemory() {
        super.onLowMemory()
        mapView?.onLowMemory()
    }

    override fun onDestroy() {
        super.onDestroy()
        mapView?.onDestroy()
    }

    override fun onResume() {
        super.onResume()
        if (Pstyle.isNullOrEmpty()) {
            Pstyle = Style.MAPBOX_STREETS
        }
        mapboxMap = binding.mapView.getMapboxMap().apply {
            loadStyle(styleExtension = prepareStyle(Pstyle!!, bitmap!!)) {
                addOnMapClickListener(this@MainActivity)
                addOnMapLongClickListener(this@MainActivity)
            }
        }
    }

    override fun onPause() {
        super.onPause()
        if (Pstyle.isNullOrEmpty()) {
            Pstyle = Style.MAPBOX_STREETS
        }
        mapboxMap = binding.mapView.getMapboxMap().apply {
            loadStyle(styleExtension = prepareStyle(Pstyle!!, bitmap!!)) {
                addOnMapClickListener(this@MainActivity)
                addOnMapLongClickListener(this@MainActivity)
            }
        }
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        locationPermissionHelper.onRequestPermissionsResult(requestCode, permissions, grantResults)
    }

    override fun onStart() {
        try {

            super.onStart()
            val intent = Intent(this, DAO::class.java)
            bindService(intent, mConnection, BIND_AUTO_CREATE)
            mapView.onStart()

            binding.mapView.location.addOnIndicatorPositionChangedListener(
                onIndicatorPositionChangedListener
            )
        } catch (ex: java.lang.Exception) {
            ex.printStackTrace()
        }
    }

    override fun onStop() {
        try {
            super.onStop()
            mapView?.onStop()

            binding.mapView.location.removeOnIndicatorPositionChangedListener(
                onIndicatorPositionChangedListener
            )
            if (mBound != null && mBound as Boolean) {
                unbindService(mConnection)
                mBound = false
            }
        } catch (ex: java.lang.Exception) {
            ex.printStackTrace()
        }

    }

    //base de datos
    private val mConnection: ServiceConnection = object : ServiceConnection {
        override fun onServiceConnected(className: ComponentName, service: IBinder) {
            try {
                val binder = service as DAO.LocalBinder
                dao = binder.getService()
                mBound = true
                //Genera LogCat de la aplicacion
            } catch (ex: Exception) {
                ex.printStackTrace()
            }
        }

        override fun onServiceDisconnected(arg0: ComponentName) {
            try {
                mBound = false
            } catch (ex: Exception) {
                ex.printStackTrace()
            }
        }
    }


    private companion object {
        const val BLUE_ICON_ID = "red"
        const val SOURCE_ID = "source_id"
        const val LAYER_ID = "layer_id"
        const val MARKER_ID_PREFIX = "view_annotation_"
        const val SELECTED_ADD_COEF_DP: Float = 8f
        const val STARTUP_TEXT =
            "Haga click sostenido en el mapa para agregar un marcador con etiqueta"
    }

    override fun onPointClick(point: Point) {
        menu_bar?.isGone = true
        favoritebookPressed = false
        recyclerView?.isGone = true
 //       reload_PM(true)
//        binding.mapView.getMapboxMap()
//            .setCamera(CameraOptions.Builder().zoom(14.0).center(point).build())
        if (pointList.isNullOrEmpty()) {
            reload_PM(false)
            reload_PM(true)
                    binding.mapView.getMapboxMap().setCamera(CameraOptions.Builder().zoom(14.0).center(point).build())
        }else{

            if(pointList.size == items_user?.size){
                binding.mapView.getMapboxMap().setCamera(CameraOptions.Builder().zoom(14.0).center(point).build())
            }else{
                reload_PM(false)
                reload_PM(true)
                binding.mapView.getMapboxMap().setCamera(CameraOptions.Builder().zoom(14.0).center(point).build())
            }

        }
    }

}
